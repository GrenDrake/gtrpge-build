// ////////////////////////////////////////////////////////////////////////////
// First string : this must be the first string used for one of the tests
//                to function correctly.
// ////////////////////////////////////////////////////////////////////////////
declare firstString "this is the first string"


// ////////////////////////////////////////////////////////////////////////////
// Data used for tests
// ////////////////////////////////////////////////////////////////////////////
declare testInt 7384
declare testStr "A Name"
declare testList [ 1 2 3 ]
declare testMap { 1: "The" 2: "End" 3: "Is" 4: "Far" }
declare testProperty $testFunc
declare testFlags flags( 6 7 8 testInt )

object first_obj
    anInt 2
    aString "Hello World!"
    aProperty $apple
    anObject object ;
    aMap { $fruit: $apple }
    aList [ 4 ]
    testMethod function() { }
;
object second_obj;


// ////////////////////////////////////////////////////////////////////////////
// Code for testing load/save
// ////////////////////////////////////////////////////////////////////////////

asm_function printMagicNumbers() {
    "\nThis morning's magic numbers are: " say
    $number1 magic_1 get_prop say ", " say
    $number2 magic_1 get_prop say ", and " say
    $number3 magic_1 get_prop say
    ". This evening's magic numbers are: " say
    $number1 magic_2 get_prop say ", " say
    $number2 magic_2 get_prop say ", and " say
    $number3 magic_2 get_prop say ".\n" say
}

object magic_1
    ident 1
    save asm_function(data) {
        $number1 self get_prop 99 data add_item
        $number2 self get_prop 99 data add_item
        $number3 self get_prop 99 data add_item
    }
    load asm_function(data) {
        0 data get_item $number1 self set_prop
        1 data get_item $number2 self set_prop
        2 data get_item $number3 self set_prop
    }
    number1 0
    number2 0
    number3 0
;

object magic_2
    ident 2
    save asm_function(data) {
        $number1 self get_prop 99 data add_item
        $number2 self get_prop 99 data add_item
        $number3 self get_prop 99 data add_item
    }
    load asm_function(data) {
        0 data get_item $number1 self set_prop
        1 data get_item $number2 self set_prop
        2 data get_item $number3 self set_prop
    }
    number1 0
    number2 0
    number3 0
;


// ////////////////////////////////////////////////////////////////////////////
// Test stack commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testStack() {
    2 4 6 8

    "\n# Testing stack manipulation\n" say

    "Testing correct initial size...[br]" say
    stack_size 4 eq testPeek jnz
    "Stack has bad initial size." error

    testPeek:
    "Testing stack peeking...[br]" say
    0 stack_peek 8 eq testPeek2 jnz
    "Failed peek at top item." error
    testPeek2:
    3 stack_peek 2 eq testPop jnz
    "Failed peek at bottom item." error

    testPop:
    "Popping item and checking stack size...[br]" say
    pop
    stack_size 3 eq testPush jnz
    "Stack has bad size after pop." error

    testPush:
    "Pushing new item and checking stack size...[br]" say
    94
    stack_size 4 eq testDup jnz
    "Stack has bad size after push." error

    testDup:
    "Duplicating top item and checking size and value...[br]" say
    stack_dup
    stack_size 5 eq testDup2 jnz
    "Stack has bad size after stack_dup." error
    testDup2:
    eq testSwap jnz
    "Duplicate item not equal to original." error

    testSwap:
    "Testing stack swapping...[br]" say
    0 2 stack_swap
    0 stack_peek 2 eq testSwapError jz
    2 stack_peek 6 eq testSwapError jz

    return

    testSwapError:
    "Stack swap failed." error
}


// ////////////////////////////////////////////////////////////////////////////
// Test function calls and arguments
// ////////////////////////////////////////////////////////////////////////////
asm_function testCall() {
    "\n# Testing function calls\n" say

    "Checking value of self on non-method...[br]" say
    self none eq oneUnspecified jnz
    "Incorrect value of self." error

    oneUnspecified:
    "Testing call with unspecified arguments...[br]" say
    24 1 testCall_onlyOne call

    "Testing call with extra arguments...[br]" say
    34 88 24 3 testCall_both call

    "Checking result of calling testCallHelperMultiply(5,6)...[br]" say
    5 6 2 testCallHelperMultiply call 30 eq testMethodCall jnz
    "testCallHelperMultiply(5,6) did not have result of 30." error

    testMethodCall:
    "Calling testCallObject.testMethod...[br]" say
    3 2 1 3 $testMethod testCallObject get_prop call
}

object testCallObject
    testMethod asm_function(arg1 arg2 arg3) {
        "[i]testMethod:[/i] Checking value of self...[br]" say
        self testCallObject eq testArg1 jnz
        "Incorrect value of self." error

        testArg1:
        "[i]testMethod:[/i] Checking argument values...[br]" say
        arg1 1 eq testArg2 jnz
        "First argument has wrong value." error
        testArg2:
        arg2 2 eq testArg3 jnz
        "Second argument has wrong value." error
        testArg3:
        arg3 3 eq done jnz
        "Third argument has wrong value." error

        done:
    }
;

asm_function testCall_onlyOne( arg1 arg2 ) {
    arg1 none eq compareArg2 jz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none eq done jnz
    "Second passed argument not none" error

    done:
}

asm_function testCall_both( arg1 arg2 : var1 ) {
    arg1 none eq compareArg2 jz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none eq compareVar1 jz
    "First passed argument had unexpected none" error

    compareVar1:
    var1 none eq done jnz
    "First non-argument local not none" error

    done:
}

asm_function testCallHelperMultiply( arg1 arg2 ) {
    arg1 arg2 mult return
}


// ////////////////////////////////////////////////////////////////////////////
// Test compare command
// ////////////////////////////////////////////////////////////////////////////
asm_function testCompare(: testValue) {
    "\n# Testing compare opcode\n" say

    "Comparing integer values...[br]" say
    5 5 eq testEqFail jnz
    "Failed 5 == 5." error

    testEqFail:
    5 10 eq testNeq jz
    "Failed 5 != 10." error

    testNeq:
    5 5 neq testNeqFail jz
    "Failed 5 == 5." error

    testNeqFail:
    5 10 neq testCmpLT jnz
    "Failed 5 != 10." error


    testCmpLT:
    5 2 lt testCmpGT jnz
    "Failed 2 < 5." error

    testCmpGT:
    2 5 gt testCmpLTE jnz
    "Failed 5 > 2." error

    testCmpLTE:
    5 2 lte testCmpLTE2 jnz
    "Failed 2 <= 5." error

    testCmpLTE2:
    5 5 lte testCmpGTE jnz
    "Failed 5 <= 5." error

    testCmpGTE:
    2 5 gte testCmpGTE2 jnz
    "Failed 5 >= 2." error

    testCmpGTE2:
    5 5 gte testCmpLtNeg jnz
    "Failed 5 >= 5." error

    testCmpLtNeg:
    5 -5 lt testCmpGtNeg jnz
    "Failed -5 < 5." error

    testCmpGtNeg:
    -5 5 gt testNonInteger jnz
    "Failed 5 > -5." error


    testNonInteger:
    "Testing non-integer comparisons...[br]" say
    none none eq testStrNone jnz
    "Failed none == none." error

    testStrNone:
    "\n" none eq testStrFunc jz
    "Failed String != none." error

    testStrFunc:
    "\n" testCompare eq testStrSelf jz
    "Failed String != Function." error

    testStrSelf:
    "\n" "\n" eq testStrStr jnz
    "Failed String != self." error

    testStrStr:
    "\n" " " eq testWithLocals jz
    "Failed String != String." error

    testWithLocals:
    "Testing using local variables...[br]" say
    5 *testValue store
    testValue 5 eq localLt jnz
    "Failed local == 5." error

    localLt:
    testValue 2 lt localGt jnz
    "Failed 2 < local." error

    localGt:
    2 testValue gt done jnz
    "Failed local > 2." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test jump commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testJumps(: testValue) {
    "\n# Testing jump opcodes\n" say

    "Testing unconditional jump...[br]" say
    test001 jmp
    "Failed unconditional jump." error

    test001:
    "Testing conditional jumps...[br]" say
    0 test002 jz
    "Failed jz (0)." error

    test002:
    1 test002_failed jz
    test003 jmp
    test002_failed:
    "Failed jz (1)." error

    test003:
    0 test003_failed jnz
    test004 jmp
    test003_failed:
    "Failed jnz (0)." error

    test004:
    1 test017 jnz
    "Failed jnz (1)." error


    test017:
    "Test jump target in local variable...[br]" say
    test018 *testValue store
    testValue jmp
    "Failed jmp w/ local." error

    test018:
    test019 *testValue store
    0 testValue jz
    "Failed jz w/ local." error

    test019:
    test024 *testValue store
    1 testValue jnz
    "Failed jnz w/ local." error

    test024:
    "Testing with value in local variable...[br]" say
    0 *testValue store
    testValue test025 jz
    "Failed jz w/ value in local." error

    test025:
    1 *testValue store
    testValue done jnz
    "Failed jnz w/ value in local." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test math commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testMath(: counter) {
    "\n# Testing math opcodes\n" say
    "Testing arithmetic...[br]" say

    5 5 add 10 eq testMinus jnz
    "Failed 5 + 5 == 10." error

    testMinus:
    5 10 sub 5 eq testMult jnz
    "Failed 10 - 5 == 5." error

    testMult:
    10 5 mult 50 eq testDiv jnz
    "Failed 10 * 5 == 50." error

    testDiv:
    5 40 div 8 eq testMod jnz
    "Failed 40 / 5 == 8." error

    testMod:
    6 40 mod 4 eq testPow jnz
    "Failed 40 % 6 == 4." error

    testPow:
    8 2 pow 256 eq testLeftShift jnz
    "Failed 2 ^ 8 == 256." error

    testLeftShift:
    "Testing bit operations...[br]" say
    4 1 left_shift 16 eq testRightShift jnz
    "Failed 1 << 4 == 16." error

    testRightShift:
    4 32 right_shift 2 eq testBitAnd jnz
    "Failed 32 >> 4 == 2." error

    testBitAnd:
    90 170 bit_and 10 eq testBitOr jnz
    "Failed 90 & 170 == 10." error

    testBitOr:
    90 170 bit_or 250 eq testBitXor jnz
    "Failed 90 | 170 == 250." error

    testBitXor:
    90 170 bit_xor 240 eq testBitNot jnz
    "Failed 90 ^ 170 == 240." error

    testBitNot:
    148 bit_not -149 eq testTruth jnz
    "Failed ~148 == -149." error

    testTruth:
    "Testing logical not...[br]" say
    0 not testNotOne jnz
    "Failed !0 == true." error

    testNotOne:
    1 not testNot37 jz
    "Failed !1 == false." error

    testNot37:
    37 not testNotNeg9 jz
    "Failed !37 == false." error

    testNotNeg9:
    -9 not testNotFred jz
    "Failed !-9 == false." error

    testNotFred:
    "Fred" not testNotEmptyString jz
    "Failed !\"Fred\" == false." error

    testNotEmptyString:
    "" not testNotFunction jz
    "Failed !\"\" == false." error

    testNotFunction:
    testMath not testNotNone jz
    "Failed !testMath() == false." error

    testNotNone:
    none not done jnz
    "Failed !none == true." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test object property commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testObjectProps() {
    "\n# Testing object manipulation opcodes\n[b][testing get_prop][/b][br]" say
    "first_obj.aString: " say
    $aString first_obj get_prop say
    " (should be \"Hello World!\")[br]" say

    "first_obj.anInt: " say
    $anInt first_obj get_prop say
    " (should be 2)[br]" say

    "second_obj.aString: " say
    $aString second_obj get_prop say
    " (should be 0)[br]" say

    "\n[b][testing has_prop][/b][br]" say
    "first_obj has property anInt? " say
    $anInt first_obj has_prop say
    " (should be 1)[br]" say

    "second_obj has property aString? " say
    $aString second_obj has_prop say
    " (should be 0)[br]" say

    "\n[b][testing set_prop][/b][br]" say
    "setting second_obj.apple to \"Fred\"[br]second_obj.apple now equals " say
    "Fred" $apple second_obj set_prop
    $apple second_obj get_prop say

    "\n[b][testing property types][/b]" say
    "[br]first_obj.anInt (1): "      say $anInt      first_obj get_prop typeof say
    "[br]first_obj.aString (2): "    say $aString    first_obj get_prop typeof say
    "[br]first_obj.aList (3): "      say $aList      first_obj get_prop typeof say
    "[br]first_obj.aMap (4): "       say $aMap       first_obj get_prop typeof say
    "[br]first_obj.testMethod (5): " say $testMethod first_obj get_prop typeof say
    "[br]first_obj.anObject (6): "   say $anObject   first_obj get_prop typeof say
    "[br]first_obj.aProperty (7): "  say $aProperty  first_obj get_prop typeof say
}


// ////////////////////////////////////////////////////////////////////////////
// Basic looping demo
// ////////////////////////////////////////////////////////////////////////////
asm_function testLoopDemo(: counter theValue) {
// show a count up loop and calculate 2^10
    0 *counter store
    1 *theValue store
    loopstart:
    counter 1 add *counter store
    2 theValue mult *theValue store
    counter say
    " " say
    counter 10 lt loopstart jnz
    "Loop finished!\n" say
    "Final result: " say
    theValue say
    "\n" say
}


// ////////////////////////////////////////////////////////////////////////////
// Test input commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testInputs() {
    "This node serves as a test of the menu selection options. Other input options can be selected in the menu below, or you can return to the top level menu." say
    "Test key input"        testGetkey     add_option
    "No extra value"        receiveExtra   add_option
    "Extra value 6"         receiveExtra   6   add_option_x
    "Extra value 73"        receiveExtra   73  add_option_x
    dispatcher get_option
}
asm_function receiveExtra(extra) {
    "Option extra value: " say extra say
    "Back to inputs menu" testInputs add_option
    dispatcher get_option
}
asm_function testGetkey() {
    "This will demonstrate and test the get_key input type." say
    "Try pressing a key." testGetkeyReceive get_key
}
asm_function testGetkeyReceive(key) {
    "Resulting character code: " say key say ".\n" say
    "Back to inputs menu" testInputs add_option
    dispatcher get_option
}


// ////////////////////////////////////////////////////////////////////////////
// Test value types
// ////////////////////////////////////////////////////////////////////////////
asm_function testValues(: localvar) {
    "\n# Testing Value Types\n" say

    "Checking basic value types...[br]" say
    testInt typeof Integer eq test_string jnz
    "Failed typeof testInt == Integer." error

    test_string:
    testStr typeof String eq test_list jnz
    "Failed typeof testStr == String." error

    test_list:
    testList typeof List eq test_map jnz
    "Failed typeof testList == List." error

    test_map:
    testMap typeof Map eq test_function jnz
    "Failed typeof testMap == Map." error

    test_function:
    testValues typeof Function eq test_object jnz
    "Failed typeof testValues == Function." error

    test_object:
    first_obj typeof Object eq test_property jnz
    "Failed typeof first_obj == testObject." error

    test_property:
    testProperty typeof Property eq test_varref jnz
    "Failed typeof testProperty == Property." error

    test_varref:
    *localvar typeof Reference eq test_flags jnz
    "Failed typeof *localvar == Reference." error

    test_flags:
    testFlags typeof Integer eq test_local jnz
    "Failed typeof testFlags == Integer." error

    test_local:
    "Testing local variable values...[br]" say
    localvar none eq test_local_2 jnz
    "Failed localvar default value == none." error

    test_local_2:
    0 *localvar store
    localvar typeof Integer eq test_casts jnz
    "Failed typeof localvar == Integer." error

    test_casts:
    "Testing type casting...[br]" say
    String localvar astype *localvar store
    localvar firstString eq all_done jnz
    "Failed localvar cast to string." error

    all_done:
}

// ////////////////////////////////////////////////////////////////////////////
// Output command tests
// ////////////////////////////////////////////////////////////////////////////
asm_function testOutput() {
    "This text (and nearly all text in these tests) is output using the \"say\" command.\nSay integer value: " say
    6215 say
    "[br]-1 using say_unsigned (should be 4294967295): " say
    -1 say_unsigned
    "[br] using say_char (should be 'A'): " say
    65 say_char
    "[br]Say UTF-8 Text: テキストの例\n" say

    "Horizontal rule below this:\n---\nTest below horizontal rule.\n" say

    "# Testing text formatting:\n" say
    "bold text: [b]Lorem ipsum dolor sit amet.[/b][br]" say
    "italic text: [i]Lorem ipsum dolor sit amet.[/i][br]" say
    "bold italic: [b][i]Lorem ipsum dolor sit amet.[/i][/b][br]" say
    "italic bold: [i][b]Lorem ipsum dolor sit amet.[/b][/i]\n" say

    "Testing multiline string. Linebreak occurs here -->

    <--\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Update info areas
// ////////////////////////////////////////////////////////////////////////////
asm_function testInfoarea() {
    "The header, footer, and title regions should now be updated. (Unless you already ran this test since starting the program.)" say

    "Good day!"     infobarLeft     set_setting
    "5:00 am"       infobarRight    set_setting
    "Fred is Cool"  infobarFooter   set_setting
    "Updated Title" infobarTitle    set_setting
}

// ////////////////////////////////////////////////////////////////////////////
// Test RNG
// ////////////////////////////////////////////////////////////////////////////
asm_function testRandom(: counter) {
    "This will generate 100 random numbers between 50 and 60 below.\n" say

    100 *counter store
    loop_start:
    counter 0 lte loop_done jnz
    50 60 random say " " say
    counter 1 sub *counter store
    loop_start jmp
    loop_done: "\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Test List Methods
// ////////////////////////////////////////////////////////////////////////////
asm_function printArray(theArray : counter length) {
    "[b]Array contents:[/b]" say
    theArray get_size *length store
    0 *counter store
    arraydumploop:
    " " say counter theArray get_item say
    counter 1 add *counter store
    length counter gt arraydumploop jnz
    " (length: " say length say ")\n" say
}

asm_function testLists(: counter random_value) {
    "\n# Testing List Operations\n" say

    "Testing list insertion...[br]" say
    testList get_size 3 eq test_add jnz
    "Test list has wrong initial size." error

    test_add:
    91 99 testList add_item
    testList get_size 4 eq test_add_initial jnz
    "Test list has wrong size after add at end." error

    test_add_initial:
    46 0 testList add_item
    testList get_size 5 eq test_add_middle jnz
    "Test list has wrong size after add at beginning." error

    test_add_middle:
    13 2 testList add_item
    testList get_size 6 eq test_list_contents jnz
    "Test list has wrong size after add in middle." error

    test_list_contents:
    0 testList get_item 46 eq test_list_contents_wrong jz
    1 testList get_item  1 eq test_list_contents_wrong jz
    2 testList get_item 13 eq test_list_contents_wrong jz
    3 testList get_item  2 eq test_list_contents_wrong jz
    4 testList get_item  3 eq test_list_contents_wrong jz
    5 testList get_item 91 eq test_list_contents_wrong jz


    "Testing changing value in list...[br]" say
    second_obj 2 testList set_item
    2 testList get_item second_obj eq test_deletion jnz
    "Failed to update list index." error


    test_deletion:
    "Testing list deletion...[br]" say
    2 testList del_item
    testList get_size 5 eq test_del_first jnz
    "Test list has wrong size after delete." error

    test_del_first:
    0 testList del_item
    testList get_size 4 eq test_del_last jnz
    "Test list has wrong size after delete." error

    test_del_last:
    3 testList del_item
    testList get_size 3 eq test_list_contents_2 jnz
    "Test list has wrong size after delete." error

    test_list_contents_2:
    0 testList get_item  1 eq test_list_contents_wrong jz
    1 testList get_item  2 eq test_list_contents_wrong jz
    2 testList get_item  3 eq test_list_contents_wrong jz


    "Testing bad list indexes...[br]" say
    -1 testList get_item 0 eq test_list_badindex jnz
    "Accessing negative list index does not return 0." error

    test_list_badindex:
    99 testList get_item 0 eq test_random jnz
    "Accessing list index beyond list size does not return 0." error


    test_random:
    "Testing getting random list items...[br]" say
    0 *counter store
    randomloop:
    testList get_random *random_value store
    random_value 1 eq randomloop_good jnz
    random_value 2 eq randomloop_good jnz
    random_value 3 eq randomloop_good jnz
    "Got unexpected value when drawing random list values." error
    randomloop_good:
    counter 1 add *counter store
    200 counter gt randomloop jnz

    return

    test_list_contents_wrong:
    "\n" say testList 1 printArray call
    "List has wrong contents." error
    return

}

// ////////////////////////////////////////////////////////////////////////////
// Test Map Methods
// ////////////////////////////////////////////////////////////////////////////
asm_function testMaps(: keys) {
    "\n# Testing Map Operations\n" say

    "Fetching map keys...[br]" say
    7 testMap get_item 0 eq test_valid_key jnz
    "Accessing invalid element returns wrong value." error

    test_valid_key:
    2 testMap get_item "End" eq test_update jnz
    "Retrieving map key \"2\" returned invalid result." error

    test_update:
    "Testing key update...[br]" say
    "Apple" 3 testMap set_item
    3 testMap get_item "Apple" eq test_newkey jnz
    "Retrieving updated map key \"3\" returned invalid result." error

    test_newkey:
    "Testing inserting new key...[br]" say
    "item" "newkey" testMap set_item
    "newkey" testMap get_item "item" eq test_haskey jnz
    "Retrieving new map key returned invalid result." error

    test_haskey:
    "Testing has_key...[br]" say
    2 testMap has_item test_haskey_2 jnz
    "Map denies having key \"2\"." error

    test_haskey_2:
    7 testMap has_item test_delete jz
    "Map claims to have key \"7\"." error

    test_delete:
    "newkey" testMap del_item
    "newkey" testMap get_item 0 eq test_key_list jnz
    "Failed to delete newkey." error

    test_key_list:
    "Converting testMap keys to list...[br]" say
    testMap get_keys *keys store
    0 keys get_item 1 eq found_bad_key jz
    1 keys get_item 2 eq found_bad_key jz
    2 keys get_item 3 eq found_bad_key jz
    3 keys get_item 4 eq found_bad_key jz
    keys get_size 4 eq all_done jnz
    "Map keys list is wrong size." error

    all_done:
    return
    found_bad_key:
    "Key list has invalid value." error
}

// ////////////////////////////////////////////////////////////////////////////
// Test Page Commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testPages() {
    "Demo Page" testPage1 'd' add_page
    "Another Page" otherPage 'a' add_page
    "Page" otherPage 'p' add_page
    "A Long Page Name" otherPage 'l' add_page
    0 testPagesReal call
}
asm_function testPagesReal() {
    "Extra pages have been added and can be activated by hotkey or by clicking on their button in the lower left." say
    "Remove \"Another Page\"" testPagesRemovePage add_option
    "Cleanup and return to main list" testPagesCleanup add_option
    dispatcher get_option
}
asm_function testPagesRemovePage() {
    "Another Page" del_page
    0 testPagesReal call
}
asm_function testPagesCleanup() {
    "Demo Page" del_page
    "Another Page" del_page
    "Page" del_page
    "A Long Page Name" del_page
    0 showOptions call
}

object testpageData
    count 1
    index 0
;
asm_function testPage1(key) {
    key typeof Integer eq showpage jz
    key 32 eq showkey jz
    end_page
    return

    leftkey:
    $index testpageData get_prop 1 sub $index testpageData set_prop
    showpage jmp
    rightkey:
    $index testpageData get_prop 1 add $index testpageData set_prop
    showpage jmp
    upkey:
    $index testpageData get_prop 10 mult $index testpageData set_prop
    showpage jmp
    downkey:
    $index testpageData get_prop 10 div $index testpageData set_prop
    showpage jmp

    showkey:
    "You pressed: " say key say " (which is not space).\n" say
    key -1 eq leftkey jnz
    key -2 eq rightkey jnz
    key -3 eq downkey jnz
    key -4 eq upkey jnz
    showpage:
    "You have viewed this page " say
    $count testpageData get_prop say
    " times. The index counter is " say
    $index testpageData get_prop say
    ". Use arrow keys to change."
    "Press space to return." testPage1 get_key
    $count testpageData get_prop 1 add $count testpageData set_prop
}
asm_function otherPage() {
    "You selected a page other than the demo page! (Only the demo page has actual content.)" say
    "Continue" none add_option
    endOtherPage get_option
}
asm_function endOtherPage() {
    end_page
}

// ////////////////////////////////////////////////////////////////////////////
// Test Dynamic Creation
// ////////////////////////////////////////////////////////////////////////////
asm_function testDynamic(: newObj newStr newList newMap) {
    "\n#Testing Dynamic Creation\n" say

    "Creating data...[br]" say
    String new *newStr store
    newStr typeof String eq makeNewObject jnz
    "New string not of String type." error

    makeNewObject:
    Object new *newObj store
    newObj typeof Object eq makeNewList jnz
    "New object not of Object type." error

    makeNewList:
    List new *newList store
    newList typeof List eq makeNewMap jnz
    "New list not of List type." error

    makeNewMap:
    Map new *newMap store
    newMap typeof Map eq testNewObjectProperties jnz
    "New map not of Map type." error


    testNewObjectProperties:
    "Testing property manipulation of created object...[br]" say
    $anInt newObj get_prop 0 eq testObjectUnsetHas jnz
    "New object returns value for unset property." error

    testObjectUnsetHas:
    $anInt newObj has_prop testObjectSet jz
    "New object claims to have anInt property." error

    testObjectSet:
    66 $anInt newObj set_prop
    $anInt newObj get_prop 66 eq testObjectSetHas jnz
    "Updated property on new object did not retain value." error

    testObjectSetHas:
    $anInt newObj has_prop testMapValues jnz
    "New object denies having anInt property." error


    testMapValues:
    "Testing values of new map...[br]" say
    "key" newMap get_item 0 eq testSetMapValue jnz
    "New map returns value for unset key...[br]" error

    testSetMapValue:
    "New Map Value" "key" newMap set_item
    "key" newMap get_item "New Map Value" eq testListValues jnz
    "New map returns 0 for updated key...[br]" error


    testListValues:
    "Testing values of new list...[br]" say
    newList get_size 0 eq testListAddValue jnz
    "New list is not empty." error

    testListAddValue:
    "New List Item" 0 newList add_item
    0 newList get_item "New List Item" eq testIsStatic jnz
    "List item not updated." error

    testIsStatic:
    "Testing isStatic...[br]" say
    testDynamic is_static reportedStaticAsDynamic jz
    "Fred" is_static reportedStaticAsDynamic jz
    testList is_static reportedStaticAsDynamic jz

    newObj is_static reportedDynamicAsStatic jnz
    newStr is_static reportedDynamicAsStatic jnz
    return

    reportedStaticAsDynamic:
    "Reported static value as dynamic." error

    reportedDynamicAsStatic:
    "Reported dynamic value as static." error

    List new List new List new say
}

// ////////////////////////////////////////////////////////////////////////////
// Test String Manipulation
// ////////////////////////////////////////////////////////////////////////////
asm_function testStringManipulation(: testString) {
    "\n# Test String Manipulation\n" say

    "Check static string \"Fred\" has length four...[br]" say
    "Fred" strlen 4 eq strlenNewString jnz
    "Bad length on static string \"Fred\"." error

    strlenNewString:
    String new *testString store
    "Check new string has zero length...[br]" say
    testString strlen strcpyStrlen jz
    "Bad initial length on new string." error

    strcpyStrlen:
    "Copying \"Fred\" to dynamic string...[br]" say
    "Fred" testString strcpy
    testString strlen 4 eq stringCompares jnz
    "Bad length on copied string \"Fred\"." error

    stringCompares:
    "Comparing static and dynamic strings with [b]==[/b]...[br]" say
    testString "Fred" eq stringCompareStrcmp jz
    "Identity of dynamic and static strings compared equal." error

    stringCompareStrcmp:
    "Comparing static and dynamic strings with [b]strcmp[/b]...[br]" say
    "Fred" testString strcmp stringAppend jz
    "Dynamic and static strings did not compare equal." error

    stringAppend:
    "Appending to test string...[br]" say
    " Lives!" testString strcat
    "Fred Lives!" testString strcmp doneStrings jz
    "String append malfunctioned." error

    doneStrings:
}

// ////////////////////////////////////////////////////////////////////////////
// All tests runner
// ////////////////////////////////////////////////////////////////////////////
asm_function doAllTests() {
    0 testJumps call
    0 testCompare call
    0 testCall call
    0 testStack call
    0 testMath call

    0 testValues call
    0 testLists call
    0 testMaps call
    0 testObjectProps call
    0 testDynamic call
    0 testStringManipulation call
}

// ////////////////////////////////////////////////////////////////////////////
// Test selection
// ////////////////////////////////////////////////////////////////////////////
asm_function showOptions() {
    true saveAllowed set_setting
    "Welcome to the feature test demo!\nSelect one of the options displayed below by entering its associated number in order to run the tests. When that is complete, you will be returned to this screen. The magic numbers below will are randomized every time you start the game, but will be maintained across saving and loading." say
    0 printMagicNumbers call

    "All non-interactive tests" doAllTests         add_option
    "Loop demo"                 testLoopDemo       add_option

    "Test jumps"                testJumps          add_option
    "Test compare"              testCompare        add_option
    "Test call"                 testCall           add_option
    "Test stack commands"       testStack          add_option
    "Test math"                 testMath           add_option

    "Test value types"          testValues         add_option
    "Test list methods"         testLists          add_option
    "Test map methods"          testMaps           add_option
    "Test object properties"    testObjectProps    add_option
    "Test dynamic objects"      testDynamic        add_option
    "Test string manipulation"  testStringManipulation  add_option

    "Test output"               testOutput         add_option
    "Test info areas"           testInfoarea       add_option
    "Test random"               testRandom         add_option

    "Test pages"                testPages          add_option
    "Test input methods"        testInputs         add_option
    dispatcher get_option
}


asm_function dispatcher(optionFunc extraValue) {
    false saveAllowed set_setting
    extraValue 1 optionFunc call

    optionFunc showOptions eq alldone jnz
    optionFunc testPages eq alldone jnz
    optionFunc testPagesReal eq alldone jnz
    optionFunc testPagesRemovePage eq alldone jnz
    optionFunc receiveExtra eq alldone jnz
    optionFunc testGetkey eq alldone jnz
    "Return to main page" showOptions add_option
    dispatcher get_option

    alldone:
    0 return
}

asm_function main(fromRestore) {
    "GTRPGE Test Suite" infobarTitle set_setting
    fromRestore all_done jnz

    // set the "magic numbers" used for demonstrate the load/save code
    10000 40000 random $number1 magic_1 set_prop
    10000 40000 random $number2 magic_1 set_prop
    10000 40000 random $number3 magic_1 set_prop
    10000 40000 random $number1 magic_2 set_prop
    10000 40000 random $number2 magic_2 set_prop
    10000 40000 random $number3 magic_2 set_prop

    all_done:
    0 showOptions call
}

declare te ""
