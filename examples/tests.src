// ////////////////////////////////////////////////////////////////////////////
// First string : this must be the first string used for one of the tests
//                to function correctly.
// ////////////////////////////////////////////////////////////////////////////
declare firstString "this is the first string"


// ////////////////////////////////////////////////////////////////////////////
// Data used for tests
// ////////////////////////////////////////////////////////////////////////////
declare testInt 7384
declare testStr "A Name"
declare testList [ 1 2 3 ]
declare testMap { 1: "The" 2: "End" 3: "Is" 4: "Far" }
declare testProperty $testFunc
declare testFlags flags( 6 7 8 testInt )

object first_obj
    $anInt 2
    $aString "Hello World!"
    $aProperty $apple
    $anObject object ;
    $aMap { $fruit: $apple }
    $aList [ 4 ]
    $testMethod function() { }
;
object second_obj
    $parent parent_obj
;

object parent_obj
    $inheritedProperty 2048
;


// ////////////////////////////////////////////////////////////////////////////
// Code for testing load/save
// ////////////////////////////////////////////////////////////////////////////

asm_function printMagicNumbers() {
    "\nThis morning's magic numbers are: " say
    $number1 magic_1 get say ", " say
    $number2 magic_1 get say ", and " say
    $number3 magic_1 get say
    ". This evening's magic numbers are: " say
    $number1 magic_2 get say ", " say
    $number2 magic_2 get say ", and " say
    $number3 magic_2 get say ".\n" say
}

object magic_1
    $ident 1
    $save asm_function(data) {
        $number1 self get 99 data ins
        $number2 self get 99 data ins
        $number3 self get 99 data ins
    }
    $load asm_function(data) {
        0 data get $number1 self set
        1 data get $number2 self set
        2 data get $number3 self set
    }
    $number1 0
    $number2 0
    $number3 0
;

object magic_2
    $ident 2
    $save asm_function(data) {
        $number1 self get 99 data ins
        $number2 self get 99 data ins
        $number3 self get 99 data ins
    }
    $load asm_function(data) {
        0 data get $number1 self set
        1 data get $number2 self set
        2 data get $number3 self set
    }
    $number1 0
    $number2 0
    $number3 0
;


// ////////////////////////////////////////////////////////////////////////////
// Test default values commands
// ////////////////////////////////////////////////////////////////////////////
default undeclaredValue 5
default declaredValue 10
declare declaredValue 20
declare otherDeclaredValue 40
default otherDeclaredValue 30
default aFunction testDefaults

function testDefaults() {
    ("\n# Testing default values\n")
    (if (neq undeclaredValue 5) (error "undeclaredValue has wrong value"))
    (if (neq declaredValue 20) (error "declaredValue has wrong value"))
    (if (neq otherDeclaredValue 40) (error "otherDeclaredValue has wrong value"))
    (if (neq aFunction testDefaults) (error "aFunction has wrong value"))
}

// ////////////////////////////////////////////////////////////////////////////
// Test stack commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testStack() {
    2 4 6 8

    "\n# Testing stack manipulation\n" say

    "Testing correct initial size...[br]" say
    stack_size 4 eq testPeek jnz
    "Stack has bad initial size." error

    testPeek:
    "Testing stack peeking...[br]" say
    0 stack_peek 8 eq testPeek2 jnz
    "Failed peek at top item." error
    testPeek2:
    3 stack_peek 2 eq testPop jnz
    "Failed peek at bottom item." error

    testPop:
    "Popping item and checking stack size...[br]" say
    pop
    stack_size 3 eq testPush jnz
    "Stack has bad size after pop." error

    testPush:
    "Pushing new item and checking stack size...[br]" say
    94
    stack_size 4 eq testDup jnz
    "Stack has bad size after push." error

    testDup:
    "Duplicating top item and checking size and value...[br]" say
    stack_dup
    stack_size 5 eq testDup2 jnz
    "Stack has bad size after stack_dup." error
    testDup2:
    eq testSwap jnz
    "Duplicate item not equal to original." error

    testSwap:
    "Testing stack swapping...[br]" say
    9 7 5 // add some dummy values
    0 2 stack_swap
    0 stack_peek 9 eq testSwapError jz
    2 stack_peek 5 eq testSwapError jz

    return

    testSwapError:
    "Stack swap failed." error
}


// ////////////////////////////////////////////////////////////////////////////
// Test function calls and arguments
// ////////////////////////////////////////////////////////////////////////////
asm_function testCall() {
    "\n# Testing function calls\n" say

    "Checking value of self on non-method...[br]" say
    self none eq oneUnspecified jnz
    "Incorrect value of self." error

    oneUnspecified:
    "Testing call with unspecified arguments...[br]" say
    24 1 testCall_onlyOne call

    "Testing call with extra arguments...[br]" say
    34 88 24 3 testCall_both call

    "Checking result of calling testCallHelperMultiply(5,6)...[br]" say
    5 6 2 testCallHelperMultiply call 30 eq testMethodCall jnz
    "testCallHelperMultiply(5,6) did not have result of 30." error

    testMethodCall:
    "Calling testCallObject.testMethod...[br]" say
    3 2 1 3 $testMethod testCallObject get call
}

object testCallObject
    $testMethod asm_function(arg1 arg2 arg3) {
        "[i]testMethod:[/i] Checking value of self...[br]" say
        self testCallObject eq testArg1 jnz
        "Incorrect value of self." error

        testArg1:
        "[i]testMethod:[/i] Checking argument values...[br]" say
        arg1 1 eq testArg2 jnz
        "First argument has wrong value." error
        testArg2:
        arg2 2 eq testArg3 jnz
        "Second argument has wrong value." error
        testArg3:
        arg3 3 eq done jnz
        "Third argument has wrong value." error

        done:
    }
;

asm_function testCall_onlyOne( arg1 arg2 ) {
    arg1 none eq compareArg2 jz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none eq done jnz
    "Second passed argument not none" error

    done:
}

asm_function testCall_both( arg1 arg2 : var1 ) {
    arg1 none eq compareArg2 jz
    "First passed argument had unexpected none" error

    compareArg2:
    arg2 none eq compareVar1 jz
    "First passed argument had unexpected none" error

    compareVar1:
    var1 none eq done jnz
    "First non-argument local not none" error

    done:
}

asm_function testCallHelperMultiply( arg1 arg2 ) {
    arg1 arg2 mult return
}


// ////////////////////////////////////////////////////////////////////////////
// Test compare command
// ////////////////////////////////////////////////////////////////////////////
asm_function testCompare(: testValue) {
    "\n# Testing compare opcode\n" say

    "Comparing integer values...[br]" say
    5 5 eq testEqFail jnz
    "Failed 5 == 5." error

    testEqFail:
    5 10 eq testNeq jz
    "Failed 5 != 10." error

    testNeq:
    5 5 neq testNeqFail jz
    "Failed 5 == 5." error

    testNeqFail:
    5 10 neq testCmpLT jnz
    "Failed 5 != 10." error


    testCmpLT:
    5 2 lt testCmpGT jnz
    "Failed 2 < 5." error

    testCmpGT:
    2 5 gt testCmpLTE jnz
    "Failed 5 > 2." error

    testCmpLTE:
    5 2 lte testCmpLTE2 jnz
    "Failed 2 <= 5." error

    testCmpLTE2:
    5 5 lte testCmpGTE jnz
    "Failed 5 <= 5." error

    testCmpGTE:
    2 5 gte testCmpGTE2 jnz
    "Failed 5 >= 2." error

    testCmpGTE2:
    5 5 gte testCmpLtNeg jnz
    "Failed 5 >= 5." error

    testCmpLtNeg:
    5 -5 lt testCmpGtNeg jnz
    "Failed -5 < 5." error

    testCmpGtNeg:
    -5 5 gt testNonInteger jnz
    "Failed 5 > -5." error


    testNonInteger:
    "Testing non-integer comparisons...[br]" say
    none none eq testStrNone jnz
    "Failed none == none." error

    testStrNone:
    "\n" none eq testStrFunc jz
    "Failed String != none." error

    testStrFunc:
    "\n" testCompare eq testStrSelf jz
    "Failed String != Function." error

    testStrSelf:
    "\n" "\n" eq testStrStr jnz
    "Failed String != self." error

    testStrStr:
    "\n" " " eq testWithLocals jz
    "Failed String != String." error

    testWithLocals:
    "Testing using local variables...[br]" say
    5 *testValue set
    testValue 5 eq localLt jnz
    "Failed local == 5." error

    localLt:
    testValue 2 lt localGt jnz
    "Failed 2 < local." error

    localGt:
    2 testValue gt done jnz
    "Failed local > 2." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test jump commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testJumps(: testValue) {
    "\n# Testing jump opcodes\n" say

    "Testing unconditional jump...[br]" say
    test001 jmp
    "Failed unconditional jump." error

    test001:
    "Testing conditional jumps...[br]" say
    0 test002 jz
    "Failed jz (0)." error

    test002:
    1 test002_failed jz
    test003 jmp
    test002_failed:
    "Failed jz (1)." error

    test003:
    0 test003_failed jnz
    test004 jmp
    test003_failed:
    "Failed jnz (0)." error

    test004:
    1 test017 jnz
    "Failed jnz (1)." error


    test017:
    "Test jump target in local variable...[br]" say
    test018 *testValue set
    testValue jmp
    "Failed jmp w/ local." error

    test018:
    test019 *testValue set
    0 testValue jz
    "Failed jz w/ local." error

    test019:
    test024 *testValue set
    1 testValue jnz
    "Failed jnz w/ local." error

    test024:
    "Testing with value in local variable...[br]" say
    0 *testValue set
    testValue test025 jz
    "Failed jz w/ value in local." error

    test025:
    1 *testValue set
    testValue done jnz
    "Failed jnz w/ value in local." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test math commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testMath(: counter) {
    "\n# Testing math opcodes\n" say
    "Testing arithmetic...[br]" say

    5 5 add 10 eq testMinus jnz
    "Failed 5 + 5 == 10." error

    testMinus:
    5 10 sub 5 eq testMult jnz
    "Failed 10 - 5 == 5." error

    testMult:
    10 5 mult 50 eq testDiv jnz
    "Failed 10 * 5 == 50." error

    testDiv:
    5 40 div 8 eq testMod jnz
    "Failed 40 / 5 == 8." error

    testMod:
    6 40 mod 4 eq testPow jnz
    "Failed 40 % 6 == 4." error

    testPow:
    8 2 pow 256 eq testLeftShift jnz
    "Failed 2 ^ 8 == 256." error

    testLeftShift:
    "Testing bit operations...[br]" say
    4 1 left_shift 16 eq testRightShift jnz
    "Failed 1 << 4 == 16." error

    testRightShift:
    4 32 right_shift 2 eq testBitAnd jnz
    "Failed 32 >> 4 == 2." error

    testBitAnd:
    90 170 bit_and 10 eq testBitOr jnz
    "Failed 90 & 170 == 10." error

    testBitOr:
    90 170 bit_or 250 eq testBitXor jnz
    "Failed 90 | 170 == 250." error

    testBitXor:
    90 170 bit_xor 240 eq testBitNot jnz
    "Failed 90 ^ 170 == 240." error

    testBitNot:
    148 bit_not -149 eq testTruth jnz
    "Failed ~148 == -149." error

    testTruth:
    "Testing logical not...[br]" say
    0 not testNotOne jnz
    "Failed !0 == true." error

    testNotOne:
    1 not testNot37 jz
    "Failed !1 == false." error

    testNot37:
    37 not testNotNeg9 jz
    "Failed !37 == false." error

    testNotNeg9:
    -9 not testNotFred jz
    "Failed !-9 == false." error

    testNotFred:
    "Fred" not testNotEmptyString jz
    "Failed !\"Fred\" == false." error

    testNotEmptyString:
    "" not testNotFunction jz
    "Failed !\"\" == false." error

    testNotFunction:
    testMath not testNotNone jz
    "Failed !testMath() == false." error

    testNotNone:
    none not done jnz
    "Failed !none == true." error

    done:
}


// ////////////////////////////////////////////////////////////////////////////
// Test object property commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testObjectProps() {
    "\n# Testing object manipulation opcodes\n[b][testing get on objects][/b][br]" say
    "first_obj.aString: " say
    $aString first_obj get say
    " (should be \"Hello World!\")[br]" say

    "first_obj.anInt: " say
    $anInt first_obj get say
    " (should be 2)[br]" say

    "second_obj.aString: " say
    $aString second_obj get say
    " (should be 0)[br]" say

    "\n[b][testing has on objects][/b][br]" say
    "first_obj has property anInt? " say
    $anInt first_obj has say
    " (should be 1)[br]" say

    "second_obj has property aString? " say
    $aString second_obj has say
    " (should be 0)[br]" say

    "\n[b][testing setp on objects][/b][br]" say
    "setting second_obj.apple to \"Fred\"[br]second_obj.apple now equals " say
    "Fred" $apple second_obj setp
    $apple second_obj get say

    "\ntesting inherited properties...[br]" say
    $inheritedProperty second_obj has 0 eq inherited_has_prop jz
    $inheritedProperty second_obj get 2048 eq inherited_wrong_value jz
    $inheritedProperty first_obj get 0 eq noparent_doesnt_have jz
    $doesNotExist second_obj get 0 eq parent_doesnt_have jz

    property_types jmp
    inherited_has_prop:     "HAS reports object own parent's property" error
    inherited_wrong_value:  "inherited property returns wrong value" error
    noparent_doesnt_have:   "unparented object returns wrong value for non-existant property" error
    parent_doesnt_have:     "parented object returns wrong value for non-existant property" error

    property_types:
    "\n[b][testing property types][/b]" say
    "[br]first_obj.anInt (1): "      say $anInt      first_obj get typeof say
    "[br]first_obj.aString (2): "    say $aString    first_obj get typeof say
    "[br]first_obj.aList (3): "      say $aList      first_obj get typeof say
    "[br]first_obj.aMap (4): "       say $aMap       first_obj get typeof say
    "[br]first_obj.testMethod (5): " say $testMethod first_obj get typeof say
    "[br]first_obj.anObject (6): "   say $anObject   first_obj get typeof say
    "[br]first_obj.aProperty (7): "  say $aProperty  first_obj get typeof say
}


// ////////////////////////////////////////////////////////////////////////////
// Testing non-asm syntax constructs
// ////////////////////////////////////////////////////////////////////////////
function testSyntaxReturn() {
    (return 5)
}
function testSyntaxReturnDefault() {
}
function testSyntax(: value) {
    (print_uf "this " "tests " "print_uf.[br]")

    (print "Testing IF true: ")
    (set value 5)
    (if value (print "Good[br]") (error "IF true failed"))
    (print "Testing IF false: ")
    (if 0 (error "IF false failed") (print "Good[br]"))
    (print "Testing IF false with no else[br]")
    (if 0 (error "IF false failed"))

    (print "Testing proc statement:")
    (if 1
        (proc
            (print " first")
            (print " second")
            (print " third"))
        (error "Reached unreachable else"))
    (print "[br]")

    (print "Testing while:")
    (set value 20)
    (while (gt value 0)
        (proc
            (print " " value)
            (dec value 2)))
    (print "[br]")

    (print "Testing while with false initial.[br]")
    (set value 1)
    (while 0 (error "While loop with false condition executed."))

    (print "Testing continue / break:")
    (set value 0)
    (while 1
        (proc
            (if (gt value 50) (break))
            (inc value)
            (if (neq (mod value 5) 0) (continue))
            (print " " value)))
    (print "[br]")

    (print "Testing do/while:")
    (set value 1)
    (do_while
        (proc
            (print " " value)
            (inc value 3))
        (lte value 20))
    (print "[br]")

    (print "Testing do/while with false condition: ")
    (do_while
        (print "in loop")
        0)
    (print "[br]")

    (print "Testing continue / break in do/while:")
    (set value 55)
    (do_while
        (proc
            (if (lte value 0) (break))
            (dec value)
            (if (neq (mod value 5) 0) (continue))
            (print " " value))
        1)
    (print "[br]")
    (print "Testing label statement: ")
    (jmp label_for_testing)
    (error "Failed to jump")
    (label label_for_testing)
    (print "Good[br]")

    (print "Testing return values of standard functions.[br]")
    (if (neq (testSyntaxReturn) 5) (error "testSyntaxReturn returned wrong value."))
    (if (neq (testSyntaxReturnDefault) 0) (error "testSyntaxReturnDefault returned wrong value."))

    ("Testing and/or constructs.[br]")
    (if (and 1 0) (error "(and 1 0) evalulated to true (should be false)"))
    (if (and 0 1) (error "(and 0 1) evalulated to true (should be false)"))
    (if (and 0 0) (error "(and 0 0) evalulated to true (should be false)"))
    (if (not (and 1 1)) (error "(and 1 1) evalulated to false (should be true)"))
    (if (and 0 0 0) (error "(and 0 0 0) evalulated to true (should be false)"))
    (if (and 1 1 0) (error "(and 1 1 0) evalulated to true (should be false)"))
    (if (not (and 1 1 1)) (error "(and 1 1 1) evalulated to false (should be true)"))
    (if (not (or 1 0)) (error "(or 1 0) evalulated to false (should be true)"))
    (if (not (or 0 1)) (error "(or 0 1) evalulated to false (should be true)"))
    (if (or 0 0) (error "(or 0 0) evalulated to true (should be false)"))
    (if (not (or 1 1)) (error "(or 1 1) evalulated to false (should be true)"))
    (if (or 0 0 0) (error "(or 0 0 0) evalulated to true (should be false)"))
    (if (not (or 1 1 0)) (error "(or 1 1 0) evalulated to false (should be true)"))
    (if (not (or 1 1 1)) (error "(or 1 1 1) evalulated to false (should be true)"))

    ("Testing makestr...[br]")
    (set value (new String))
    (makestr value "This is " 55 " good.")
    (if (strcmp value "This is 55 good.")
        (error "Did not create string correctly."))
}


// ////////////////////////////////////////////////////////////////////////////
// Basic looping demo
// ////////////////////////////////////////////////////////////////////////////
asm_function testLoopDemo(: counter theValue) {
// show a count up loop and calculate 2^10
    0 *counter set
    1 *theValue set
    loopstart:
    counter 1 add *counter set
    2 theValue mult *theValue set
    counter say
    " " say
    counter 10 gt loopstart jnz
    "Loop finished!\n" say
    "Final result: " say
    theValue say
    "\n" say
}


// ////////////////////////////////////////////////////////////////////////////
// Test input commands
// ////////////////////////////////////////////////////////////////////////////
function testInputs() {
    ("This node serves as a test of the menu selection options. Other input options can be selected in the menu below, or you can return to the top level menu.")
    (option "Test key input"        testGetkey)
    (option "Test line input"       testLineInput)
    (option "No extra value"        receiveExtra)
    (option "Extra value 6"         receiveExtra   6)
    (option "Extra value 73"        receiveExtra   73)
    (option "Value 0 (key: G)"      receiveExtra   0    'g')
    (get_option dispatcher)
}
asm_function receiveExtra(extra) {
    "Option extra value: " say extra say
    "Back to inputs menu" testInputs none none add_option
    dispatcher get_option
}
asm_function testGetkey() {
    "This will demonstrate and test the get_key input type." say
    "Try pressing a key." testGetkeyReceive get_key
}
asm_function testGetkeyReceive(key) {
    "Resulting character code: " say key say ".\n" say
    "Back to inputs menu" testInputs none none add_option
    dispatcher get_option
}
object lineInputHolder
    $lastLine "(nothing yet)"
;
function testLineInput() {
    ("Testing line input option.\nThe last line you entered was: ")
    (print (get lineInputHolder $lastLine) "\n")
    (get_line testLineInputReceive "Enter some text:")
}
function testLineInputReceive(text) {
    ("You entered: \"" text "\".\n")
    (setp lineInputHolder $lastLine text)
    (option "Back to inputs menu" testInputs)
    (get_option dispatcher)
}


// ////////////////////////////////////////////////////////////////////////////
// Test value types
// ////////////////////////////////////////////////////////////////////////////
asm_function testValues(: localvar) {
    "\n# Testing Value Types\n" say

    "Checking basic value types...[br]" say
    testInt typeof Integer eq test_string jnz
    "Failed typeof testInt == Integer." error

    test_string:
    testStr typeof String eq test_list jnz
    "Failed typeof testStr == String." error

    test_list:
    testList typeof List eq test_map jnz
    "Failed typeof testList == List." error

    test_map:
    testMap typeof Map eq test_function jnz
    "Failed typeof testMap == Map." error

    test_function:
    testValues typeof Function eq test_object jnz
    "Failed typeof testValues == Function." error

    test_object:
    first_obj typeof Object eq test_property jnz
    "Failed typeof first_obj == testObject." error

    test_property:
    testProperty typeof Property eq test_varref jnz
    "Failed typeof testProperty == Property." error

    test_varref:
    *localvar typeof Reference eq test_flags jnz
    "Failed typeof *localvar == Reference." error

    test_flags:
    testFlags typeof Integer eq test_local jnz
    "Failed typeof testFlags == Integer." error

    test_local:
    "Testing local variable values...[br]" say
    localvar none eq test_local_2 jnz
    "Failed localvar default value == none." error

    test_local_2:
    0 *localvar set
    localvar typeof Integer eq test_casts jnz
    "Failed typeof localvar == Integer." error

    test_casts:
    "Testing type casting...[br]" say
    String localvar astype *localvar set
    localvar firstString eq all_done jnz
    "Failed localvar cast to string." error

    all_done:
}

// ////////////////////////////////////////////////////////////////////////////
// Output command tests
// ////////////////////////////////////////////////////////////////////////////
asm_function testOutput() {
    "This text (and nearly all text in these tests) is output using the \"say\" command.\nSay integer value: " say
    6215 say
    "[br]-1 using say_unsigned (should be 4294967295): " say
    -1 say_unsigned
    "[br] using say_char (should be 'A'): " say
    65 say_char
    "[br]Say UTF-8 Text: テキストの例\n" say

    "Horizontal rule below this:\n---\nTest below horizontal rule.\n" say

    "# Testing text formatting:\n" say
    "bold text: [b]Lorem ipsum dolor sit amet.[/b][br]" say
    "italic text: [i]Lorem ipsum dolor sit amet.[/i][br]" say
    "bold italic: [b][i]Lorem ipsum dolor sit amet.[/i][/b][br]" say
    "italic bold: [i][b]Lorem ipsum dolor sit amet.[/b][/i]\n" say

    "Testing multiline string. Linebreak occurs here -->

    <--\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Update info areas
// ////////////////////////////////////////////////////////////////////////////
asm_function testInfoarea() {
    "The header, footer, and title regions should now be updated. (Unless you already ran this test since starting the program.)" say

    "Good day!"     infobarLeft     set_setting
    "5:00 am"       infobarRight    set_setting
    "Fred is Cool"  infobarFooter   set_setting
    "Updated Title" infobarTitle    set_setting
}

// ////////////////////////////////////////////////////////////////////////////
// Test RNG
// ////////////////////////////////////////////////////////////////////////////
asm_function testRandom(: counter) {
    "This will generate 200 random numbers between 50 and 60 below.\n" say

    200 *counter set
    loop_start:
    counter 0 gte loop_done jnz
    50 60 random say " " say
    1 counter sub *counter set
    counter loop_start jz
    20 counter mod 0 eq no_nl jz
    "[br]" say
    loop_start jmp
    no_nl:
    10 counter mod 0 eq loop_start jz
    " : " say
    loop_start jmp
    loop_done: "\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Test Fetching Debug / Origin Info
// ////////////////////////////////////////////////////////////////////////////
asm_function testOrigins() {
    //fromRestore all_done jnz
    "main: "            say main            origin say "\n" say
    "testInt: "         say testInt         origin say "\n" say
    "testStr: "         say testStr         origin say "\n" say
    "testList: "        say testList        origin say "\n" say
    "testMap: "         say testMap         origin say "\n" say
    "testProperty: "    say testProperty    origin say "\n" say
    "testFlags: "       say testFlags       origin say "\n" say
    "first_obj: "       say first_obj       origin say "\n" say
    // "dynamic: "         say List new        origin say "\n" say

    // "firstobj.testmethod: " say
    // $testMethod first_obj get origin say
    // "\n" say
}

// ////////////////////////////////////////////////////////////////////////////
// Test List Methods
// ////////////////////////////////////////////////////////////////////////////
asm_function printArray(theArray : counter length) {
    "[b]Array contents:[/b]" say
    theArray size *length set
    0 *counter set
    arraydumploop:
    " " say counter theArray get say
    counter 1 add *counter set
    length counter gt arraydumploop jnz
    " (length: " say length say ")\n" say
}

asm_function testLists(: counter random_value) {
    "\n# Testing List Operations\n" say

    "Testing list insertion...[br]" say
    testList size 3 eq test_add jnz
    "Test list has wrong initial size." error

    test_add:
    91 99 testList ins
    testList size 4 eq test_add_initial jnz
    "Test list has wrong size after add at end." error

    test_add_initial:
    46 0 testList ins
    testList size 5 eq test_add_middle jnz
    "Test list has wrong size after add at beginning." error

    test_add_middle:
    13 2 testList ins
    testList size 6 eq test_list_contents jnz
    "Test list has wrong size after add in middle." error

    test_list_contents:
    0 testList get 46 eq test_list_contents_wrong jz
    1 testList get  1 eq test_list_contents_wrong jz
    2 testList get 13 eq test_list_contents_wrong jz
    3 testList get  2 eq test_list_contents_wrong jz
    4 testList get  3 eq test_list_contents_wrong jz
    5 testList get 91 eq test_list_contents_wrong jz


    "Testing list pop/push...[br]" say
    1024 testList list_push
    testList size 7 eq test_list_push_value jnz
    "list_push did not increase list size." error

    test_list_push_value:
    6 testList get 1024 neq test_list_pop jz
    "Pushed list item has wrong value"

    test_list_pop:
    testList list_pop *counter set
    testList size 6 eq test_list_pop_value jnz
    "list_pop did not decrease list size." error

    test_list_pop_value:
    1024 counter eq test_list_set jnz
    "list_pop returned wrong value" error


    test_list_set:
    "Testing changing value in list...[br]" say
    second_obj 2 testList setp
    2 testList get second_obj eq test_deletion jnz
    "Failed to update list index." error


    test_deletion:
    "Testing list deletion...[br]" say
    2 testList del
    testList size 5 eq test_del_first jnz
    "Test list has wrong size after delete." error

    test_del_first:
    0 testList del
    testList size 4 eq test_del_last jnz
    "Test list has wrong size after delete." error

    test_del_last:
    3 testList del
    testList size 3 eq test_list_contents_2 jnz
    "Test list has wrong size after delete." error

    test_list_contents_2:
    0 testList get  1 eq test_list_contents_wrong jz
    1 testList get  2 eq test_list_contents_wrong jz
    2 testList get  3 eq test_list_contents_wrong jz


    "Testing bad list indexes...[br]" say
    -1 testList get 0 eq test_list_badindex jnz
    "Accessing negative list index does not return 0." error

    test_list_badindex:
    99 testList get 0 eq test_random jnz
    "Accessing list index beyond list size does not return 0." error


    test_random:
    "Testing getting random list items...[br]" say
    0 *counter set
    randomloop:
    testList get_random *random_value set
    random_value 1 eq randomloop_good jnz
    random_value 2 eq randomloop_good jnz
    random_value 3 eq randomloop_good jnz
    "Got unexpected value when drawing random list values." error
    randomloop_good:
    counter 1 add *counter set
    200 counter gt randomloop jnz

    return

    test_list_contents_wrong:
    "\n" say testList 1 printArray call
    "List has wrong contents." error
    return

}

// ////////////////////////////////////////////////////////////////////////////
// Test Map Methods
// ////////////////////////////////////////////////////////////////////////////
asm_function testMaps(: keys) {
    "\n# Testing Map Operations\n" say

    "Fetching map keys...[br]" say
    7 testMap get 0 eq test_valid_key jnz
    "Accessing invalid element returns wrong value." error

    test_valid_key:
    2 testMap get "End" eq test_update jnz
    "Retrieving map key \"2\" returned invalid result." error

    test_update:
    "Testing key update...[br]" say
    "Apple" 3 testMap setp
    3 testMap get "Apple" eq test_newkey jnz
    "Retrieving updated map key \"3\" returned invalid result." error

    test_newkey:
    "Testing inserting new key...[br]" say
    "item" "newkey" testMap setp
    "newkey" testMap get "item" eq test_haskey jnz
    "Retrieving new map key returned invalid result." error

    test_haskey:
    "Testing has_key...[br]" say
    2 testMap has test_haskey_2 jnz
    "Map denies having key \"2\"." error

    test_haskey_2:
    7 testMap has test_delete jz
    "Map claims to have key \"7\"." error

    test_delete:
    "newkey" testMap del
    "newkey" testMap get 0 eq test_key_list jnz
    "Failed to delete newkey." error

    test_key_list:
    "Converting testMap keys to list...[br]" say
    testMap get_keys *keys set
    0 keys get 1 eq found_bad_key jz
    1 keys get 2 eq found_bad_key jz
    2 keys get 3 eq found_bad_key jz
    3 keys get 4 eq found_bad_key jz
    keys size 4 eq all_done jnz
    "Map keys list is wrong size." error

    all_done:
    return
    found_bad_key:
    "Key list has invalid value." error
}

// ////////////////////////////////////////////////////////////////////////////
// Test Page Commands
// ////////////////////////////////////////////////////////////////////////////
asm_function testPages() {
    "Demo Page" testPage1 'd' add_page
    "Another Page" otherPage 'a' add_page
    "Page" otherPage 'p' add_page
    "A Long Page Name" otherPage 'l' add_page
    0 testPagesReal call
}
asm_function testPagesReal() {
    "Extra pages have been added and can be activated by hotkey or by clicking on their button in the lower left." say
    "Remove \"Another Page\"" testPagesRemovePage none none add_option
    "Cleanup and return to main list" testPagesCleanup none none add_option
    dispatcher get_option
}
asm_function testPagesRemovePage() {
    "Another Page" del_page
    0 testPagesReal call
}
asm_function testPagesCleanup() {
    "Demo Page" del_page
    "Another Page" del_page
    "Page" del_page
    "A Long Page Name" del_page
    0 showOptions call
}

object testpageData
    $count 1
    $index 0
;
asm_function testPage1(key) {
    key typeof Integer eq showpage jz
    key 32 eq showkey jz
    end_page
    return

    leftkey:
    $index testpageData get 1 sub $index testpageData setp
    showpage jmp
    rightkey:
    $index testpageData get 1 add $index testpageData setp
    showpage jmp
    upkey:
    $index testpageData get 10 mult $index testpageData setp
    showpage jmp
    downkey:
    $index testpageData get 10 div $index testpageData setp
    showpage jmp

    showkey:
    "You pressed: " say key say " (which is not space).\n" say
    key -1 eq leftkey jnz
    key -2 eq rightkey jnz
    key -3 eq downkey jnz
    key -4 eq upkey jnz
    showpage:
    "You have viewed this page " say
    $count testpageData get say
    " times. The index counter is " say
    $index testpageData get say
    ". Use arrow keys to change."
    "Press space to return." testPage1 get_key
    $count testpageData get 1 add $count testpageData setp
}
asm_function otherPage() {
    "You selected a page other than the demo page! (Only the demo page has actual content.)" say
    "Continue" none none none add_option
    endOtherPage get_option
}
asm_function endOtherPage() {
    end_page
}

// ////////////////////////////////////////////////////////////////////////////
// Test Dynamic Creation
// ////////////////////////////////////////////////////////////////////////////
asm_function testDynamic(: newObj newStr newList newMap) {
    "\n#Testing Dynamic Creation\n" say

    "Creating data...[br]" say
    String new *newStr set
    newStr typeof String eq makeNewObject jnz
    "New string not of String type." error

    makeNewObject:
    Object new *newObj set
    newObj typeof Object eq makeNewList jnz
    "New object not of Object type." error

    makeNewList:
    List new *newList set
    newList typeof List eq makeNewMap jnz
    "New list not of List type." error

    makeNewMap:
    Map new *newMap set
    newMap typeof Map eq testNewObjectProperties jnz
    "New map not of Map type." error


    testNewObjectProperties:
    "Testing property manipulation of created object...[br]" say
    $anInt newObj get 0 eq testObjectUnsetHas jnz
    "New object returns value for unset property." error

    testObjectUnsetHas:
    $anInt newObj has testObjectSet jz
    "New object claims to have anInt property." error

    testObjectSet:
    66 $anInt newObj setp
    $anInt newObj get 66 eq testObjectSetHas jnz
    "Updated property on new object did not retain value." error

    testObjectSetHas:
    $anInt newObj has testMapValues jnz
    "New object denies having anInt property." error


    testMapValues:
    "Testing values of new map...[br]" say
    "key" newMap get 0 eq testSetMapValue jnz
    "New map returns value for unset key...[br]" error

    testSetMapValue:
    "New Map Value" "key" newMap setp
    "key" newMap get "New Map Value" eq testListValues jnz
    "New map returns 0 for updated key...[br]" error


    testListValues:
    "Testing values of new list...[br]" say
    newList size 0 eq testListAddValue jnz
    "New list is not empty." error

    testListAddValue:
    "New List Item" 0 newList ins
    0 newList get "New List Item" eq testIsStatic jnz
    "List item not updated." error

    testIsStatic:
    "Testing isStatic...[br]" say
    testDynamic is_static reportedStaticAsDynamic jz
    "Fred" is_static reportedStaticAsDynamic jz
    testList is_static reportedStaticAsDynamic jz

    newObj is_static reportedDynamicAsStatic jnz
    newStr is_static reportedDynamicAsStatic jnz
    return

    reportedStaticAsDynamic:
    "Reported static value as dynamic." error

    reportedDynamicAsStatic:
    "Reported dynamic value as static." error

    List new List new List new say
}

// ////////////////////////////////////////////////////////////////////////////
// Test String Manipulation
// ////////////////////////////////////////////////////////////////////////////
asm_function testStringManipulation(: testString) {
    "\n# Test String Manipulation\n" say

    "Check static string \"Fred\" has length four...[br]" say
    "Fred" strlen 4 eq strlenNewString jnz
    "Bad length on static string \"Fred\"." error

    strlenNewString:
    String new *testString set
    "Check new string has zero length...[br]" say
    testString strlen strcpyStrlen jz
    "Bad initial length on new string." error

    strcpyStrlen:
    "Copying \"Fred\" to dynamic string...[br]" say
    "Fred" testString strcat
    testString strlen 4 eq stringCompares jnz
    "Bad length on copied string \"Fred\"." error

    stringCompares:
    "Comparing static and dynamic strings with [b]==[/b]...[br]" say
    testString "Fred" eq stringCompareStrcmp jz
    "Identity of dynamic and static strings compared equal." error

    stringCompareStrcmp:
    "Comparing static and dynamic strings with [b]strcmp[/b]...[br]" say
    "Fred" testString strcmp stringAppend jz
    "Dynamic and static strings did not compare equal." error

    stringAppend:
    "Appending to test string...[br]" say
    " Lives!" testString strcat
    "Fred Lives!" testString strcmp doneStrings jz
    "String append malfunctioned." error

    doneStrings:
}

// ////////////////////////////////////////////////////////////////////////////
// All tests runner
// ////////////////////////////////////////////////////////////////////////////
asm_function doAllTests() {
    0 testJumps call
    0 testCompare call
    0 testCall call
    0 testStack call
    0 testMath call
    0 testDefaults call

    0 testValues call
    0 testLists call
    0 testMaps call
    0 testObjectProps call
    0 testDynamic call
    0 testStringManipulation call
}

// ////////////////////////////////////////////////////////////////////////////
// Test selection
// ////////////////////////////////////////////////////////////////////////////
function showOptions() {
    (set_setting saveAllowed true)
    ("Welcome to the feature test demo!\nSelect one of the options displayed below by entering its associated number in order to run the tests. When that is complete, you will be returned to this screen. The magic numbers below will are randomized every time you start the game, but will be maintained across saving and loading.")
    (printMagicNumbers)

    (option "All non-interactive tests" doAllTests)
    (option "Loop demo"                 testLoopDemo)

    (option "Test jumps"                testJumps)
    (option "Test compare"              testCompare)
    (option "Test call"                 testCall)
    (option "Test stack commands"       testStack)
    (option "Test math"                 testMath)
    (option "Test default values"       testDefaults)

    (option "Test value types"          testValues)
    (option "Test list methods"         testLists)
    (option "Test map methods"          testMaps)
    (option "Test object properties"    testObjectProps)
    (option "Test dynamic objects"      testDynamic)
    (option "Test string manipulation"  testStringManipulation)

    (option "Test syntax constructs"    testSyntax)

    (option "Test output"               testOutput)
    (option "Test info areas"           testInfoarea)
    (option "Test random"               testRandom)
    (option "Test origins"              testOrigins)

    (option "Test pages"                testPages)
    (option "Test input methods"        testInputs)
    (get_option dispatcher)
}


asm_function dispatcher(optionFunc extraValue) {
    false saveAllowed set_setting
    extraValue 1 optionFunc call

    optionFunc showOptions eq alldone jnz
    optionFunc testPages eq alldone jnz
    optionFunc testPagesReal eq alldone jnz
    optionFunc testPagesRemovePage eq alldone jnz
    optionFunc receiveExtra eq alldone jnz
    optionFunc testGetkey eq alldone jnz
    optionFunc testLineInput eq alldone jnz
    "Return to main page" showOptions none none add_option
    dispatcher get_option

    alldone:
    0 return
}

asm_function main(fromRestore) {
    "GTRPGE Test Suite" infobarTitle set_setting
    "GTRPGE Test Suite" infobarLeft set_setting
    fromRestore all_done jnz

    // set the "magic numbers" used for demonstrate the load/save code
    10000 40000 random $number1 magic_1 setp
    10000 40000 random $number2 magic_1 setp
    10000 40000 random $number3 magic_1 setp
    10000 40000 random $number1 magic_2 setp
    10000 40000 random $number2 magic_2 setp
    10000 40000 random $number3 magic_2 setp

    all_done:
    0 showOptions call
}

declare te ""
